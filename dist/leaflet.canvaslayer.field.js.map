{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./Cell.js","webpack:///../node_modules/@turf/inside/index.js","webpack:///../node_modules/@turf/invariant/index.js","webpack:///./layer/L.CanvasLayer.js","webpack:///./layer/L.CanvasLayer.SimpleLonLat.js","webpack:///./layer/L.CanvasLayer.Field.js","webpack:///./layer/L.CanvasLayer.ScalarField.js","webpack:///./layer/L.CanvasLayer.VectorFieldAnim.js","webpack:///./control/L.Control.ColorBar.js","webpack:///./Vector.js","webpack:///./Field.js","webpack:///./ScalarField.js","webpack:///./VectorField.js","webpack:///./_main.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Cell","center","xSize","ySize","arguments","length","undefined","_classCallCheck","this","anotherCell","equals","_equalValues","anotherValue","type","constructor","Number","Vector","u","v","halfX","halfY","cLat","lat","cLng","lng","ul","L","latLng","lr","latLngBounds","invariant","getCoord","getCoords","inRing","pt","ring","ignoreBoundary","isInside","slice","j","xi","yi","xj","yj","point","polygon","Error","polys","geometry","bbox","inBBox","insidePoly","inHole","k","obj","coordinates","containsNumber","Array","isArray","getGeom","geojson","geometries","geojsonType","collectionOf","featureCollection","features","feature","featureOf","getGeomType","geom","CanvasLayer","Layer","extend","initialize","options","_map","_canvas","_frame","_delegate","setOptions","delegate","del","needRedraw","Util","requestAnimFrame","drawLayer","_onLayerDidResize","resizeEvent","width","newSize","x","height","y","_onLayerDidMove","topLeft","containerPointToLayerPoint","DomUtil","setPosition","getEvents","events","resize","moveend","zoomAnimation","Browser","any3d","zoomanim","_animateZoom","onAdd","map","tiles","size","getSize","animated","addClass","_panes","overlayPane","appendChild","on","onLayerDidMount","onRemove","onLayerWillUnmount","getPanes","removeChild","off","addTo","addLayer","LatLonToMercator","latlon","Math","PI","log","tan","bounds","getBounds","zoom","getZoom","getCenter","corner","containerPointToLatLng","onDrawLayer","layer","canvas","e","scale","getZoomScale","offset","_latLngToNewLayerPoint","getNorthWest","setTransform","canvasLayer","SimpleLonLat","color","points","setData","data","viewInfo","g","getContext","clearRect","fillStyle","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","next","done","latLngToContainerPoint","beginPath","fillRect","fill","closePath","stroke","err","return","xs","ys","xmin","min","apply","_toConsumableArray","ymin","xmax","max","ymax","southWest","northEast","simpleLonLat","lonslats","Field","mouseMoveCursor","noValue","opacity","onClick","onMouseMove","inFilter","field","_visible","zoomstart","_hideCanvas","zoomend","_showCanvas","_enableIdentify","_ensureCanvasAlignment","show","hide","_disableIdentify","isVisible","style","visibility","_onClick","_onMouseMove","_field","TypeError","setFilter","fire","f","setOpacity","_updateOpacity","bb","extent","_queryValue","_changeCursorOn","_options$mouseMoveCur","getContainer","cursor","valueAt","latlng","_getDrawingContext","ScalarField","interpolate","vectorSize","arrowDirection","scalarField","_defaultColorScale","chroma","domain","range","setColor","_getRendererMethod","_drawImage","_drawArrows","_ensureColor","ctx","img","createImageData","_prepareImageIn","putImageData","pos","pointCoords","lon","_color$rgba","_getColorFor","rgba","_color$rgba2","_slicedToArray","R","G","B","A","parseInt","_pixelBounds","pixelSize","nCols","stride","floor","strokeStyle","currentBounds","mapRange","getNorth","getSouth","getEast","getWest","legendSize","bufferSize","legendOrigin","getSouthWest","legendArrowCenters","horizontal","vertical","legendBoxNorthEast","direction","angle","cell","cellXSize","cellYSize","_drawArrow","_field$_lonLatAtIndex","_lonLatAtIndexes","_field$_lonLatAtIndex2","magnitude","contains","northWest","southEast","getSouthEast","save","projected","translate","rotationRads","rotate","moveTo","lineTo","restore","VectorFieldAnim","paths","fade","duration","maxAge","velocityScale","vectorField","timer","_stopAnimation","_prepareParticlePaths","d3","prev","forEach","par","age","self","randomPosition","vector","xt","yt","hasValueAt","globalCompositeOperation","lineWidth","_drawParticle","source","target","pA","pB","_randomAge","push","random","stop","vectorFieldAnim","Control","ColorBar","position","margin","background","textColor","steps","decimals","units","title","labels","labelFontSize","labelTextPosition","div","padding","DomEvent","addListener","stopPropagation","preventDefault","backgroundColor","innerHTML","palette","document","createElement","select","append","attr","text","svg","_createSvgIn","_appendColorBarTo","_appendLabelsTo","spaceForLabels","_this","colorPerValue","_getColorPerValue","w","buckets","selectAll","enter","hex","toFixed","_this2","positionPerLabelValue","_getPositionPerLabelValue","_this3","_range","delta","xPositionFor","scaleLinear","control","colorBar","sqrt","inDegrees","atan2","directionTo","params","Field_classCallCheck","nRows","xllCorner","yllCorner","xurCorner","yurCorner","grid","isContinuous","longitudeNeedsToBeWrapped","_inFilter","_spatialMask","_calculateRange","cells","_lonLatAtIndexes2","_lonLatAtIndexes3","_valueAtIndexes","_updateRange","_getWrappedLongitudes2","_getWrappedLongitudes","_getWrappedLongitudes3","_pointInMask","_pointInExtent","_getWrappedLongitudes4","_getWrappedLongitudes5","longitudeIn","latitudeIn","properties","poly","inside","notContains","_getDecimalIndexes2","_getDecimalIndexes","_getDecimalIndexes3","interpolatedValueAtIndexes","indexes","_getFourSurroundingIndexes","_indexes","fi","ci","fj","cj","values","_getFourSurroundingValues","_values","g00","g10","g01","g11","_doInterpolation","_clampColumnIndex","_clampRowIndex","row","_isValid","_getDecimalIndexes4","_getDecimalIndexes5","ii","jj","hasValue","included","_longitudeAtX","_latitudeAtY","halfXPixel","halfYPixel","maxCol","maxRow","ScalarField_classCallCheck","_possibleConstructorReturn","__proto__","getPrototypeOf","zs","_buildGrid","asc","scaleFactor","lines","split","header","_parseASCIIGridHeader","line","trim","it","floatItem","parseFloat","noDataValue","headerLines","headerItems","items","filter","_defineProperty","toUpperCase","usesCorner","cellSize","bandIndex","multipleFromGeoTIFF","bandIndexes","image","GeoTIFF","parse","getImage","rasters","readRasters","tiepoint","getTiePoints","fileDirectory","getFileDirectory","_fileDirectory$ModelP","ScalarField_slicedToArray","ModelPixelScale","xScale","yScale","keys","GDAL_NODATA","noData","from","z","getWidth","getHeight","_arrayTo2d","array","rx","ry","VectorField","VectorField_classCallCheck","VectorField_possibleConstructorReturn","us","vs","ascU","ascV","fromASCIIGrid","_paramsFromScalarFields","gtU","gtV","fromGeoTIFF","geotiffData","bandIndexesForUV","_ScalarField$multiple","_ScalarField$multiple2","VectorField_slicedToArray","_getFunctionFor","_applyOnField","func","numCells","_arraysTo2d","valid","vectors","getCells","magnitudes","a","b","window","require","console"],"mappings":"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","file":"leaflet.canvaslayer.field.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","/**\n *  Simple regular cell in a raster\n */\nexport default class Cell {\n    /**\n     * A simple cell with a numerical value\n     * @param {L.LatLng} center\n     * @param {Number|Vector} value\n     * @param {Number} xSize\n     * @param {Number} ySize\n     */\n    constructor(center, value, xSize, ySize = xSize) {\n        this.center = center;\n        this.value = value;\n        this.xSize = xSize;\n        this.ySize = ySize;\n    }\n\n    equals(anotherCell) {\n        return (\n            this.center.equals(anotherCell.center) &&\n            this._equalValues(this.value, anotherCell.value) &&\n            this.xSize === anotherCell.xSize &&\n            this.ySize === anotherCell.ySize\n        );\n    }\n\n    _equalValues(value, anotherValue) {\n        let type = value.constructor.name;\n        let answerFor = {\n            Number: value === anotherValue,\n            Vector: value.u === anotherValue.u && value.v === anotherValue.v\n        };\n        return answerFor[type];\n    }\n\n    /**\n     * Bounds for the cell\n     * @returns {LatLngBounds}\n     */\n    getBounds() {\n        let halfX = this.xSize / 2.0;\n        let halfY = this.ySize / 2.0;\n        let cLat = this.center.lat;\n        let cLng = this.center.lng;\n        let ul = L.latLng([cLat + halfY, cLng - halfX]);\n        let lr = L.latLng([cLat - halfY, cLng + halfX]);\n\n        return L.latLngBounds(\n            L.latLng(lr.lat, ul.lng),\n            L.latLng(ul.lat, lr.lng)\n        );\n    }\n}\n","var invariant = require('@turf/invariant');\nvar getCoord = invariant.getCoord;\nvar getCoords = invariant.getCoords;\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name inside\n * @param {Feature<Point>} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {boolean} [ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.inside(pt, poly);\n * //= true\n */\nmodule.exports = function (point, polygon, ignoreBoundary) {\n    // validation\n    if (!point) throw new Error('point is required');\n    if (!polygon) throw new Error('polygon is required');\n\n    var pt = getCoord(point);\n    var polys = getCoords(polygon);\n    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;\n    var bbox = polygon.bbox;\n\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) return false;\n\n    // normalize to multipolygon\n    if (type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n};\n\n/**\n * inRing\n *\n * @private\n * @param {[number, number]} pt [x,y]\n * @param {Array<[number, number]>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0], yi = ring[i][1];\n        var xj = ring[j][0], yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) return !ignoreBoundary;\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\n/**\n * inBBox\n *\n * @private\n * @param {[number, number]} pt point [x,y]\n * @param {[number, number, number, number]} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n           bbox[1] <= pt[1] &&\n           bbox[2] >= pt[0] &&\n           bbox[3] >= pt[1];\n}\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {string} GeoJSON Geometry Type\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeomType(point)\n * //=\"Point\"\n */\nfunction getGeomType(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    var geom = getGeom(geojson);\n    if (geom) return geom.type;\n}\n\nmodule.exports = {\n    geojsonType: geojsonType,\n    collectionOf: collectionOf,\n    featureOf: featureOf,\n    getCoord: getCoord,\n    getCoords: getCoords,\n    containsNumber: containsNumber,\n    getGeom: getGeom,\n    getGeomType: getGeomType\n};\n","/*\n  1.0.1 (downloaded from https://github.com/Sumbera/gLayers.Leaflet/releases/tag/v1.0.1)\n\n  Generic  Canvas Layer for leaflet 0.7 and 1.0-rc,\n  copyright Stanislav Sumbera,  2016 , sumbera.com , license MIT\n  originally created and motivated by L.CanvasOverlay  available here: https://gist.github.com/Sumbera/11114288\n*/\n\nL.CanvasLayer = L.Layer.extend({\n    // -- initialized is called on prototype\n    initialize: function (options) {\n        this._map = null;\n        this._canvas = null;\n        this._frame = null;\n        this._delegate = null;\n        L.setOptions(this, options);\n    },\n\n    delegate: function (del) {\n        this._delegate = del;\n        return this;\n    },\n\n    needRedraw: function () {\n        if (!this._frame) {\n            this._frame = L.Util.requestAnimFrame(this.drawLayer, this);\n        }\n        return this;\n    },\n\n    //-------------------------------------------------------------\n    _onLayerDidResize: function (resizeEvent) {\n        this._canvas.width = resizeEvent.newSize.x;\n        this._canvas.height = resizeEvent.newSize.y;\n    },\n    //-------------------------------------------------------------\n    _onLayerDidMove: function () {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n        this.drawLayer();\n    },\n    //-------------------------------------------------------------\n    getEvents: function () {\n        var events = {\n            resize: this._onLayerDidResize,\n            moveend: this._onLayerDidMove\n        };\n        if (this._map.options.zoomAnimation && L.Browser.any3d) {\n            events.zoomanim = this._animateZoom;\n        }\n\n        return events;\n    },\n    //-------------------------------------------------------------\n    onAdd: function (map) {\n        this._map = map;\n        this._canvas = L.DomUtil.create('canvas', 'leaflet-layer');\n        this.tiles = {};\n\n        var size = this._map.getSize();\n        this._canvas.width = size.x;\n        this._canvas.height = size.y;\n\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n        L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\n\n\n        map._panes.overlayPane.appendChild(this._canvas);\n\n        map.on(this.getEvents(), this);\n\n        var del = this._delegate || this;\n        del.onLayerDidMount && del.onLayerDidMount(); // -- callback\n\n        this.needRedraw();\n    },\n\n    //-------------------------------------------------------------\n    onRemove: function (map) {\n        var del = this._delegate || this;\n        del.onLayerWillUnmount && del.onLayerWillUnmount(); // -- callback\n\n\n        map.getPanes().overlayPane.removeChild(this._canvas);\n\n        map.off(this.getEvents(), this);\n\n        this._canvas = null;\n\n    },\n\n    //------------------------------------------------------------\n    addTo: function (map) {\n        map.addLayer(this);\n        return this;\n    },\n    // --------------------------------------------------------------------------------\n    LatLonToMercator: function (latlon) {\n        return {\n            x: latlon.lng * 6378137 * Math.PI / 180,\n            y: Math.log(Math.tan((90 + latlon.lat) * Math.PI / 360)) * 6378137\n        };\n    },\n\n    //------------------------------------------------------------------------------\n    drawLayer: function () {\n        // -- todo make the viewInfo properties  flat objects.\n        var size = this._map.getSize();\n        var bounds = this._map.getBounds();\n        var zoom = this._map.getZoom();\n\n        var center = this.LatLonToMercator(this._map.getCenter());\n        var corner = this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize()));\n\n        var del = this._delegate || this;\n        del.onDrawLayer && del.onDrawLayer({\n            layer: this,\n            canvas: this._canvas,\n            bounds: bounds,\n            size: size,\n            zoom: zoom,\n            center: center,\n            corner: corner\n        });\n        this._frame = null;\n    },\n\n    //------------------------------------------------------------------------------\n    _animateZoom: function (e) {\n        var scale = this._map.getZoomScale(e.zoom);\n        var offset = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center);\n\n        L.DomUtil.setTransform(this._canvas, offset, scale);\n    }\n});\n\nL.canvasLayer = function () {\n    return new L.CanvasLayer();\n};\n","/**\n *  Simple layer with lon-lat points\n *\n *  TODO rename to SimplePoint?\n */\nL.CanvasLayer.SimpleLonLat = L.CanvasLayer.extend({\n    options: {\n        color: 'gray'\n    },\n\n    initialize: function(points, options) {\n        this.points = points;\n        L.Util.setOptions(this, options);\n    },\n\n    onLayerDidMount: function() {\n        // -- prepare custom drawing\n    },\n\n    onLayerWillUnmount: function() {\n        // -- custom cleanup\n    },\n\n    /* eslint-disable no-unused-vars */\n    setData: function(data) {\n        // -- custom data set\n        this.needRedraw(); // -- call to drawLayer\n    },\n    /* eslint-enable no-unused-vars */\n\n    onDrawLayer: function(viewInfo) {\n        // canvas preparation\n        let g = viewInfo.canvas.getContext('2d');\n        g.clearRect(0, 0, viewInfo.canvas.width, viewInfo.canvas.height);\n        g.fillStyle = this.options.color;\n\n        for (let point of this.points) {\n            let p = viewInfo.layer._map.latLngToContainerPoint(point);\n            g.beginPath();\n            //g.arc(p.x, p.y, 1, 0, Math.PI * 2); // circle | TODO style 'function' as parameter?\n            g.fillRect(p.x, p.y, 2, 2); //simple point\n            g.fill();\n            g.closePath();\n            g.stroke();\n        }\n    },\n\n    getBounds: function() {\n        // TODO: bounding with points...\n        let xs = this.points.map(pt => pt.lng);\n        let ys = this.points.map(pt => pt.lat);\n\n        let xmin = Math.min(...xs);\n        let ymin = Math.min(...ys);\n        let xmax = Math.max(...xs);\n        let ymax = Math.max(...ys);\n\n        let southWest = L.latLng(ymin, xmin),\n            northEast = L.latLng(ymax, xmax);\n        let bounds = L.latLngBounds(southWest, northEast); // TODO FIX ERROR ? half-pixel?\n        return bounds;\n    }\n});\n\nL.canvasLayer.simpleLonLat = function(lonslats, options) {\n    return new L.CanvasLayer.SimpleLonLat(lonslats, options);\n};\n","/**\n * Abstract class for a Field layer on canvas, aka 'a Raster layer'\n * (ScalarField or a VectorField)\n */\nL.CanvasLayer.Field = L.CanvasLayer.extend({\n    options: {\n        mouseMoveCursor: {\n            value: 'pointer',\n            noValue: 'default'\n        },\n        opacity: 1,\n        onClick: null,\n        onMouseMove: null,\n        inFilter: null\n    },\n\n    initialize: function(field, options) {\n        L.Util.setOptions(this, options);\n        this._visible = true;\n        if (field) {\n            this.setData(field);\n        }\n    },\n\n    getEvents: function() {\n        var events = L.CanvasLayer.prototype.getEvents.call(this);\n        events.zoomstart = this._hideCanvas.bind(this);\n        events.zoomend = this._showCanvas.bind(this);\n        return events;\n    },\n\n    onLayerDidMount: function() {\n        this._enableIdentify();\n        this._ensureCanvasAlignment();\n    },\n\n    show() {\n        this._visible = true;\n        this._showCanvas();\n        this._enableIdentify();\n    },\n\n    hide() {\n        this._visible = false;\n        this._hideCanvas();\n        this._disableIdentify();\n    },\n\n    isVisible() {\n        return this._visible;\n    },\n\n    _showCanvas() {\n        if (this._canvas && this._visible) {\n            this._canvas.style.visibility = 'visible';\n        }\n    },\n\n    _hideCanvas() {\n        if (this._canvas) {\n            this._canvas.style.visibility = 'hidden';\n        }\n    },\n\n    _enableIdentify() {\n        this._map.on('click', this._onClick, this);\n        this._map.on('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.on('click', this.options.onClick, this);\n        this.options.onMouseMove &&\n            this.on('mousemove', this.options.onMouseMove, this);\n    },\n\n    _disableIdentify() {\n        this._map.off('click', this._onClick, this);\n        this._map.off('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.off('click', this.options.onClick, this);\n        this.options.onMouseMove &&\n            this.off('mousemove', this.options.onMouseMove, this);\n    },\n\n    _ensureCanvasAlignment() {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n    },\n\n    onLayerWillUnmount: function() {\n        this._disableIdentify();\n    },\n\n    needRedraw() {\n        if (this._map && this._field) {\n            L.CanvasLayer.prototype.needRedraw.call(this);\n        }\n    },\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function(viewInfo) {\n        throw new TypeError('Must be overriden');\n    },\n    /* eslint-enable no-unused-vars */\n\n    setData: function(field) {\n        this.options.inFilter && field.setFilter(this.options.inFilter);\n        this._field = field;\n        this.needRedraw();\n        this.fire('load');\n    },\n\n    setFilter: function(f) {\n        this.options.inFilter = f;\n        this._field && this._field.setFilter(f);\n        this.needRedraw();\n    },\n\n    setOpacity: function(opacity) {\n        this.options.opacity = opacity;\n\n        if (this._canvas) {\n            this._updateOpacity();\n        }\n        return this;\n    },\n\n    getBounds: function() {\n        let bb = this._field.extent();\n\n        let southWest = L.latLng(bb[1], bb[0]),\n            northEast = L.latLng(bb[3], bb[2]);\n        let bounds = L.latLngBounds(southWest, northEast);\n        return bounds;\n    },\n\n    _onClick: function(e) {\n        let v = this._queryValue(e);\n        this.fire('click', v);\n    },\n\n    _onMouseMove: function(e) {\n        let v = this._queryValue(e);\n        this._changeCursorOn(v);\n        this.fire('mousemove', v);\n    },\n\n    _changeCursorOn: function(v) {\n        if (!this.options.mouseMoveCursor) return;\n\n        let { value, noValue } = this.options.mouseMoveCursor;\n        let style = this._map.getContainer().style;\n        style.cursor = v.value !== null ? value : noValue;\n    },\n\n    _updateOpacity: function() {\n        L.DomUtil.setOpacity(this._canvas, this.options.opacity);\n    },\n\n    _queryValue: function(e) {\n        let v = this._field\n            ? this._field.valueAt(e.latlng.lng, e.latlng.lat)\n            : null;\n        let result = {\n            latlng: e.latlng,\n            value: v\n        };\n        return result;\n    },\n\n    _getDrawingContext: function() {\n        let g = this._canvas.getContext('2d');\n        g.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        return g;\n    }\n});\n","import Cell from '../Cell';\n\n/**\n * ScalarField on canvas (a 'Raster')\n */\nL.CanvasLayer.ScalarField = L.CanvasLayer.Field.extend({\n    options: {\n        type: 'colormap', // [colormap|vector]\n        color: null, // function colorFor(value) [e.g. chromajs.scale],\n        interpolate: false, // Change to use interpolation\n        vectorSize: null, // only used if 'vector'\n        arrowDirection: 'from' // [from|towards]\n    },\n\n    initialize: function(scalarField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(\n                this,\n                scalarField,\n                options\n        );\n        L.Util.setOptions(this, options);\n    },\n\n    _defaultColorScale: function() {\n        return chroma.scale(['white', 'black']).domain(this._field.range);\n    },\n\n    setColor(f) {\n        this.options.color = f;\n        this.needRedraw();\n    },\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function(viewInfo) {\n        if (!this.isVisible()) return;\n        this._updateOpacity();\n\n        let r = this._getRendererMethod();\n        // console.time('onDrawLayer');\n        r();\n        // console.timeEnd('onDrawLayer');\n    },\n    /* eslint-enable no-unused-vars */\n\n    _getRendererMethod: function() {\n        switch (this.options.type) {\n            case 'colormap':\n                return this._drawImage.bind(this);\n            case 'vector':\n                return this._drawArrows.bind(this);\n            default:\n                throw Error(`Unkwown renderer type: ${this.options.type}`);\n        }\n    },\n\n    _ensureColor: function() {\n        if (this.options.color === null) {\n            this.setColor(this._defaultColorScale());\n        }\n    },\n\n    _showCanvas() {\n        L.CanvasLayer.Field.prototype._showCanvas.call(this);\n        this.needRedraw(); // TODO check spurious redraw (e.g. hide/show\n        // without moving map)\n    },\n\n    /**\n     * Draws the field in an ImageData and applying it with putImageData. Used\n     * as a reference:\n     * http://geoexamples.com/d3-raster-tools-docs/code_samples/raster-pixels-page.html\n     */\n    _drawImage: function() {\n        this._ensureColor();\n\n        let ctx = this._getDrawingContext();\n        let width = this._canvas.width;\n        let height = this._canvas.height;\n\n        let img = ctx.createImageData(width, height);\n        let data = img.data;\n\n        this._prepareImageIn(data, width, height);\n        ctx.putImageData(img, 0, 0);\n    },\n\n    /**\n     * Prepares the image in data, as array with RGBAs [R1, G1, B1, A1, R2, G2,\n     * B2, A2...]\n     * \n     * @private\n     * @param {[[Type]]}\n     *                data [[Description]]\n     * @param {Numver}\n     *                width\n     * @param {Number}\n     *                height\n     */\n    _prepareImageIn(data, width, height) {\n        let f = this.options.interpolate ? 'interpolatedValueAt' : 'valueAt';\n\n        let pos = 0;\n        for (let j = 0; j < height; j++) {\n            for (let i = 0; i < width; i++) {\n                let pointCoords = this._map.containerPointToLatLng([i, j]);\n                let lon = pointCoords.lng;\n                let lat = pointCoords.lat;\n\n                let v = this._field[f](lon, lat); // 'valueAt' |\n                // 'interpolatedValueAt' ||\n                // TODO check some\n                // 'artifacts'\n                if (v !== null) {\n                    let color = this._getColorFor(v);\n                    let [R, G, B, A] = color.rgba();\n                    data[pos] = R;\n                    data[pos + 1] = G;\n                    data[pos + 2] = B;\n                    data[pos + 3] = parseInt(A * 255); // not percent in alpha\n                    // but hex 0-255\n                }\n                pos = pos + 4;\n            }\n        }\n    },\n\n    /**\n     * Draws the field as a set of arrows. Direction from 0 to 360 is assumed.\n     */\n    _drawArrows: function() {\n        const bounds = this._pixelBounds();\n        const pixelSize = (bounds.max.x - bounds.min.x) / this._field.nCols;\n\n        var stride = Math.max(\n                1,\n                Math.floor(20 / pixelSize)\n        );\n\n        const ctx = this._getDrawingContext();\n        ctx.strokeStyle = this.options.color;\n\n        var currentBounds = this._map.getBounds();\n\n        /* draw legend scale */\n        /* TODO add color and draw white background and stuff */\n        let mapRange = {\n            'lat': currentBounds.getNorth() - currentBounds.getSouth(), \n            'lng': currentBounds.getEast() - currentBounds.getWest()\n        };\n        \n        /* size of scale in percentage of map canvas */\n        let legendSize = (mapRange['lat'] + mapRange['lng']) / 2 * 0.04;\n        let bufferSize = (mapRange['lat'] + mapRange['lng']) / 2 * 0.014;\n        \n        let legendOrigin = {\n            'lat': currentBounds.getSouthWest()['lat'],\n            'lng': currentBounds.getSouthWest()['lng']\n        };\n\n        let legendArrowCenters = {\n            'horizontal': {\n                'lat': legendOrigin['lat'] + bufferSize,\n                'lng': legendOrigin['lng'] + legendSize\n            },\n            'vertical': {\n                'lat': legendOrigin['lat'] + legendSize,\n                'lng': legendOrigin['lng'] + bufferSize\n            }\n        };\n\n        let legendBoxNorthEast = {\n            'lat': legendOrigin['lat'] + legendSize + bufferSize * 3,\n            'lng': legendOrigin['lng'] + legendSize + bufferSize * 3\n        };\n\n        for (let direction in legendArrowCenters) {\n            let angle;\n\n            if (direction == 'horizontal') {\n                angle = 270;\n            } else if (direction == 'vertical') {\n                angle = 180;\n            }\n\n            let cell = new Cell(\n                    legendArrowCenters[direction],\n                    angle,\n                    this.cellXSize,\n                    this.cellYSize\n            );\n            this._drawArrow(cell, ctx, 1);\n        }\n\n        /* draw arrows */\n        for (var y = 0; y < this._field.height; y = y + stride) {\n            for (var x = 0; x < this._field.width; x = x + stride) {\n                let [lon, lat] = this._field._lonLatAtIndexes(x, y);\n                let direction = this._field.valueAt(lon, lat);\n                let magnitude = this.options.vectorSize ? this.options.vectorSize.valueAt(lon, lat) : null;\n\n                let center = L.latLng(lat, lon);\n                if (direction !== null) {\n                    if (currentBounds.contains(center)) {\n                        if (!(lon <= legendBoxNorthEast['lng'] && lat <= legendBoxNorthEast['lat'])) {\n                            let cell = new Cell(\n                                    center,\n                                    direction,\n                                    this.cellXSize,\n                                    this.cellYSize\n                            );\n                            this._drawArrow(cell, ctx, magnitude);\n                        }\n                    }\n                }\n            }\n        }\n    },\n\n    _pixelBounds: function() {\n        const bounds = this.getBounds();\n        const northWest = this._map.latLngToContainerPoint(\n                bounds.getNorthWest()\n        );\n        const southEast = this._map.latLngToContainerPoint(\n                bounds.getSouthEast()\n        );\n        var pixelBounds = L.bounds(northWest, southEast);\n        return pixelBounds;\n    },\n\n    _drawArrow: function(cell, ctx, magnitude) {\n        // colormap vs. simple color\n        let color = this.options.color;\n        if (typeof color === 'function') {\n            ctx.strokeStyle = color(cell.value);\n        }\n\n        // get current magnitude\n        const size = magnitude != null ? magnitude * 50 : 20;\n\n        // save canvas state\n        ctx.save();\n\n        var projected = this._map.latLngToContainerPoint(cell.center);\n        ctx.translate(projected.x, projected.y);\n\n        // calculate and apply rotation\n        let rotationRads = (90 + cell.value) * Math.PI / 180;\n        if (this.options.arrowDirection === 'towards') {\n            rotationRads = rotationRads + Math.PI;\n        }\n        ctx.rotate(rotationRads);\n\n        // begin creating arrow\n        ctx.beginPath();\n\n        // draw arrow shaft\n        ctx.moveTo(-size / 2, 0);\n        ctx.lineTo(+size / 2, 0);\n\n        // draw arrow point, somehow\n        ctx.moveTo(size * 0.25, -size * 0.25);\n        ctx.lineTo(+size / 2, 0);\n        ctx.lineTo(size * 0.25, size * 0.25);\n\n        // draw arrow\n        ctx.stroke();\n\n        // go back to saved state (reset for next arrow)\n        ctx.restore();\n    },\n\n    /**\n     * Gets a chroma color for a pixel value, according to 'options.color'\n     */\n    _getColorFor(v) {\n        let c = this.options.color; // e.g. for a constant 'red'\n        if (typeof c === 'function') {\n            c = this.options.color(v);\n        }\n        let color = chroma(c); // to be more flexible, a chroma color object is\n        // always created || TODO improve efficiency\n        return color;\n    }\n});\n\nL.canvasLayer.scalarField = function(scalarField, options) {\n    return new L.CanvasLayer.ScalarField(scalarField, options);\n};\n","/**\n * Animated VectorField on canvas\n */\nL.CanvasLayer.VectorFieldAnim = L.CanvasLayer.Field.extend({\n    options: {\n        paths: 800,\n        color: 'white', // html-color | function colorFor(value) [e.g. chromajs.scale]\n        width: 1.0, // number | function widthFor(value)\n        fade: 0.96, // 0 to 1\n        duration: 20, // milliseconds per 'frame'\n        maxAge: 200, // number of maximum frames per path\n        velocityScale: 1 / 5000\n    },\n\n    initialize: function(vectorField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(\n            this,\n            vectorField,\n            options\n        );\n        L.Util.setOptions(this, options);\n\n        this.timer = null;\n    },\n\n    onLayerDidMount: function() {\n        L.CanvasLayer.Field.prototype.onLayerDidMount.call(this);\n        this._map.on('move resize', this._stopAnimation, this);\n    },\n\n    onLayerWillUnmount: function() {\n        L.CanvasLayer.Field.prototype.onLayerWillUnmount.call(this);\n        this._map.off('move resize', this._stopAnimation, this);\n        this._stopAnimation();\n    },\n\n    _hideCanvas: function _showCanvas() {\n        L.CanvasLayer.Field.prototype._hideCanvas.call(this);\n        this._stopAnimation();\n    },\n\n    onDrawLayer: function(viewInfo) {\n        if (!this._field || !this.isVisible()) return;\n\n        this._updateOpacity();\n\n        let ctx = this._getDrawingContext();\n        let paths = this._prepareParticlePaths();\n\n        this.timer = d3.timer(function() {\n            _moveParticles();\n            _drawParticles();\n        }, this.options.duration);\n\n        let self = this;\n\n        /**\n         * Builds the paths, adding 'particles' on each animation step, considering\n         * their properties (age / position source > target)\n         */\n        function _moveParticles() {\n            // let screenFactor = 1 / self._map.getZoom(); // consider using a 'screenFactor' to ponderate velocityScale\n            paths.forEach(function(par) {\n                if (par.age > self.options.maxAge) {\n                    // restart, on a random x,y\n                    par.age = 0;\n                    self._field.randomPosition(par);\n                }\n\n                let vector = self._field.valueAt(par.x, par.y);\n                if (vector === null) {\n                    par.age = self.options.maxAge;\n                } else {\n                    // the next point will be...\n                    let xt = par.x + vector.u * self.options.velocityScale; //* screenFactor;\n                    let yt = par.y + vector.v * self.options.velocityScale; //* screenFactor;\n\n                    if (self._field.hasValueAt(xt, yt)) {\n                        par.xt = xt;\n                        par.yt = yt;\n                        par.m = vector.magnitude();\n                    } else {\n                        // not visible anymore...\n                        par.age = self.options.maxAge;\n                    }\n                }\n                par.age += 1;\n            });\n        }\n\n        /**\n         * Draws the paths on each step\n         */\n        function _drawParticles() {\n            // Previous paths...\n            let prev = ctx.globalCompositeOperation;\n            ctx.globalCompositeOperation = 'destination-in';\n            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            //ctx.globalCompositeOperation = 'source-over';\n            ctx.globalCompositeOperation = prev;\n\n            // fading paths...\n            ctx.fillStyle = `rgba(0, 0, 0, ${self.options.fade})`;\n            ctx.lineWidth = self.options.width;\n            ctx.strokeStyle = self.options.color;\n\n            // New paths\n            paths.forEach(function(par) {\n                self._drawParticle(viewInfo, ctx, par);\n            });\n        }\n    },\n\n    _drawParticle(viewInfo, ctx, par) {\n        let source = new L.latLng(par.y, par.x);\n        let target = new L.latLng(par.yt, par.xt);\n\n        if (\n            viewInfo.bounds.contains(source) &&\n            par.age <= this.options.maxAge\n        ) {\n            let pA = viewInfo.layer._map.latLngToContainerPoint(source);\n            let pB = viewInfo.layer._map.latLngToContainerPoint(target);\n\n            ctx.beginPath();\n            ctx.moveTo(pA.x, pA.y);\n            ctx.lineTo(pB.x, pB.y);\n\n            // next-step movement\n            par.x = par.xt;\n            par.y = par.yt;\n\n            // colormap vs. simple color\n            let color = this.options.color;\n            if (typeof color === 'function') {\n                ctx.strokeStyle = color(par.m);\n            }\n\n            let width = this.options.width;\n            if (typeof width === 'function') {\n                ctx.lineWidth = width(par.m);\n            }\n\n            ctx.stroke();\n        }\n    },\n\n    _prepareParticlePaths: function() {\n        let paths = [];\n\n        for (var i = 0; i < this.options.paths; i++) {\n            let p = this._field.randomPosition();\n            p.age = this._randomAge();\n            paths.push(p);\n        }\n        return paths;\n    },\n\n    _randomAge: function() {\n        return Math.floor(Math.random() * this.options.maxAge);\n    },\n\n    _stopAnimation: function() {\n        if (this.timer) {\n            this.timer.stop();\n        }\n    }\n});\n\nL.canvasLayer.vectorFieldAnim = function(vectorField, options) {\n    return new L.CanvasLayer.VectorFieldAnim(vectorField, options);\n};\n","/**\n *   Control for a simple legend with a colorbar\n *   References:\n *      - http://jsfiddle.net/ramnathv/g8stqcf6/\n *      - http://jsfiddle.net/vis4/cYLZH/\n */\nL.Control.ColorBar = L.Control.extend({\n    options: {\n        position: 'bottomleft',\n        width: 300, // for colorbar itself (control is wider)\n        height: 15,\n        margin: 15,\n        background: '#fff',\n        textColor: 'black',\n        steps: 100,\n        decimals: 2,\n        units: 'uds', // ej: m/s\n        title: 'Legend', // ej: Ocean Currents\n        labels: [], // empty for no labels\n        labelFontSize: 10,\n        labelTextPosition: 'middle' // start | middle | end\n    },\n\n    initialize: function(color, range, options) {\n        this.color = color; // 'chromajs' scale function\n        this.range = range; // [min, max]\n        L.Util.setOptions(this, options);\n    },\n\n    onAdd: function(map) {\n        this._map = map;\n        let div = L.DomUtil.create(\n            'div',\n            'leaflet-control-colorBar leaflet-bar leaflet-control'\n        );\n        div.style.padding = '10px';\n\n        L.DomEvent\n            .addListener(div, 'click', L.DomEvent.stopPropagation)\n            .addListener(div, 'click', L.DomEvent.preventDefault);\n        div.style.backgroundColor = this.options.background;\n        div.style.cursor = 'text';\n        div.innerHTML = this.title() + this.palette();\n        return div;\n    },\n\n    title: function() {\n        let d = document.createElement('div');\n        d3\n            .select(d)\n            .append('span')\n            .style('color', this.options.textColor)\n            .style('display', 'block')\n            .style('margin-bottom', '5px')\n            .attr('class', 'leaflet-control-colorBar-title')\n            .text(this.options.title);\n        return d.innerHTML;\n    },\n\n    palette: function() {\n        let d = document.createElement('div');\n        let svg = this._createSvgIn(d);\n\n        this._appendColorBarTo(svg);\n\n        if (this.options.labels) {\n            this._appendLabelsTo(svg);\n        }\n\n        return d.innerHTML;\n    },\n\n    _createSvgIn: function(d) {\n        let spaceForLabels = this.options.labels ? this.options.margin : 0;\n        let svg = d3\n            .select(d)\n            .append('svg')\n            .attr('width', this.options.width + this.options.margin * 2)\n            .attr('height', this.options.height + spaceForLabels);\n        return svg;\n    },\n\n    _appendColorBarTo: function(svg) {\n        const colorPerValue = this._getColorPerValue();\n        const w = this.options.width / colorPerValue.length;\n\n        let groupBars = svg.append('g').attr('id', 'colorBar-buckets');\n        let buckets = groupBars\n            .selectAll('rect')\n            .data(colorPerValue)\n            .enter()\n            .append('rect');\n        buckets\n            .attr('x', (d, i) => i * w + this.options.margin)\n            .attr('y', () => 0)\n            .attr('height', () => this.options.height /*w * 4*/)\n            .attr('width', () => w)\n            .attr('stroke-width', 2)\n            .attr('stroke-linecap', 'butt')\n            .attr('stroke', d => d.color.hex())\n            .attr('fill', d => d.color.hex());\n        buckets\n            .append('title')\n            .text(\n                d =>\n                    `${d.value.toFixed(this.options.decimals)} ${this.options\n                        .units}`\n            );\n    },\n\n    _appendLabelsTo: function(svg) {\n        const positionPerLabelValue = this._getPositionPerLabelValue();\n        //const w = this.options.width / colorPerValue.length;\n        let groupLabels = svg.append('g').attr('id', 'colorBar-labels');\n        let labels = groupLabels\n            .selectAll('text')\n            .data(positionPerLabelValue)\n            .enter()\n            .append('text');\n        labels\n            .attr('x', d => d.position + this.options.margin)\n            .attr('y', this.options.height + this.options.margin)\n            .attr('font-size', `${this.options.labelFontSize}px`)\n            .attr('text-anchor', this.options.labelTextPosition)\n            .attr('fill', this.options.textColor)\n            .attr('class', 'leaflet-control-colorBar-label')\n            .text(d => `${d.value.toFixed(this.options.decimals)}`);\n    },\n\n    _getColorPerValue: function() {\n        const [min, max] = this.range;\n        let delta = (max - min) / this.options.steps;\n        let data = d3.range(min, max + delta, delta);\n        let colorPerValue = data.map(d => {\n            return {\n                value: d,\n                color: this.color(d)\n            };\n        });\n        return colorPerValue;\n    },\n\n    _getPositionPerLabelValue: function() {\n        var xPositionFor = d3\n            .scaleLinear()\n            .range([0, this.options.width])\n            .domain(this.range);\n        let data = this.options.labels;\n        let positionPerLabel = data.map(d => {\n            return {\n                value: d,\n                position: xPositionFor(d)\n            };\n        });\n        return positionPerLabel;\n    }\n});\n\nL.control.colorBar = function(color, range, options) {\n    return new L.Control.ColorBar(color, range, options);\n};\n","/**\n *  2D Vector\n */\nexport default class Vector {\n\n    constructor(u, v) {\n        this.u = u;\n        this.v = v;\n    }\n\n    /**\n     * Magnitude\n     * @returns {Number}\n     */\n    magnitude() {\n        return Math.sqrt(this.u * this.u + this.v * this.v);\n    }\n\n    /**\n     * Angle in degrees (0 to 360) --> Towards\n     * N is 0 and E is 90\n     * @returns {Number}\n     */\n    directionTo() {\n        let verticalAngle = Math.atan2(this.u, this.v);\n        let inDegrees = verticalAngle * (180.0 / Math.PI);\n        if (inDegrees < 0) {\n            inDegrees = inDegrees + 360.0;\n        }\n        return inDegrees;\n    }\n\n    /**\n     * Angle in degrees (0 to 360) From x-->\n     * N is 0 and E is 90\n     * @returns {Number}\n     */\n    directionFrom() {\n        let a = this.directionTo();\n        let opposite = (a + 180.0) % 360.0;\n        return opposite;\n    }\n\n    /*\n        Degrees --> text\n        new Dictionary<int, string>\n        {\n            //{0, 23, 45, 68, 90, 113, 135, 158, 180, 203, 225, 248, 270, 293, 315, 338, 360};\n            {0, 'N'},\n            {23, 'NNE'},\n            {45, 'NE'},\n            {68, 'ENE'},\n            {90, 'E'},\n            {113, 'ESE'},\n            {135, 'SE'},\n            {158, 'SSE'},\n            {180, 'S'},\n            {203, 'SSW'},\n            {225, 'SW'},\n            {248, 'WSW'},\n            {270, 'W'},\n            {293, 'WNW'},\n            {315, 'NW'},\n            {338, 'NNW'},\n            {360, 'N'}\n        };\n    */\n}\n","import Cell from './Cell';\nimport inside from '@turf/inside';\n\n/**\n *  Abstract class for a set of values (Vector | Scalar)\n *  assigned to a regular 2D-grid (lon-lat), aka 'a Raster source'\n */\nexport default class Field {\n    constructor(params) {\n        this.params = params;\n\n        this.nCols = params['nCols'];\n        this.nRows = params['nRows'];\n\n        // alias\n        this.width = params['nCols'];\n        this.height = params['nRows'];\n\n        // ll = lower-left\n        this.xllCorner = params['xllCorner'];\n        this.yllCorner = params['yllCorner'];\n\n        // ur = upper-right\n        this.xurCorner =\n            params['xllCorner'] + params['nCols'] * params['cellXSize'];\n        this.yurCorner =\n            params['yllCorner'] + params['nRows'] * params['cellYSize'];\n\n        this.cellXSize = params['cellXSize'];\n        this.cellYSize = params['cellYSize'];\n\n        this.grid = null; // to be defined by subclasses\n        this.isContinuous = this.xurCorner - this.xllCorner >= 360;\n        this.longitudeNeedsToBeWrapped = this.xurCorner > 180; // [0, 360] --> [-180, 180]\n\n        this._inFilter = null;\n        this._spatialMask = null;\n    }\n\n    /**\n     * Builds a grid with a value at each point (either Vector or Number)\n     * Original params must include the required input values, following\n     * x-ascending & y-descending order (same as in ASCIIGrid)\n     * @abstract\n     * @private\n     * @returns {Array.<Array.<Vector|Number>>} - grid[row][column]--> Vector|Number\n     */\n    _buildGrid() {\n        throw new TypeError('Must be overriden');\n    }\n\n    _updateRange() {\n        this.range = this._calculateRange();\n    }\n\n    /**\n     * Number of cells in the grid (rows * cols)\n     * @returns {Number}\n     */\n    numCells() {\n        return this.nRows * this.nCols;\n    }\n\n    /**\n     * A list with every cell\n     * @returns {Array<Cell>} - cells (x-ascending & y-descending order)\n     */\n    getCells(stride = 1) {\n        let cells = [];\n        for (let j = 0; j < this.nRows; j = j + stride) {\n            for (let i = 0; i < this.nCols; i = i + stride) {\n                let [lon, lat] = this._lonLatAtIndexes(i, j);\n                let center = L.latLng(lat, lon);\n                let value = this._valueAtIndexes(i, j);\n                let c = new Cell(center, value, this.cellXSize, this.cellYSize);\n                cells.push(c); // <<\n            }\n        }\n        return cells;\n    }\n\n    /**\n     * Apply a filter function to field values\n     * @param   {Function} f - boolean function\n     */\n    setFilter(f) {\n        this._inFilter = f;\n        this._updateRange();\n    }\n\n    /**\n     * Apply a spatial mask to field values\n     * @param {L.GeoJSON} m \n     */\n    setSpatialMask(m) {\n        this._spatialMask = m;\n    }\n\n    /**\n     * Grid extent\n     * @returns {Number[]} [xmin, ymin, xmax, ymax]\n     */\n    extent() {\n        let [xmin, xmax] = this._getWrappedLongitudes();\n        return [xmin, this.yllCorner, xmax, this.yurCorner];\n    }\n\n    /**\n     * [xmin, xmax] in [-180, 180] range\n     */\n    _getWrappedLongitudes() {\n        let xmin = this.xllCorner;\n        let xmax = this.xurCorner;\n\n        if (this.longitudeNeedsToBeWrapped) {\n            if (this.isContinuous) {\n                xmin = -180;\n                xmax = 180;\n            } else {\n                // not sure about this (just one particular case, but others...?)\n                xmax = this.xurCorner - 360;\n                xmin = this.xllCorner - 360;\n                /* eslint-disable no-console */\n                // console.warn(`are these xmin: ${xmin} & xmax: ${xmax} OK?`);\n                // TODO: Better throw an exception on no-controlled situations.\n                /* eslint-enable no-console */\n            }\n        }\n        return [xmin, xmax];\n    }\n\n    /**\n     * Returns whether or not the grid contains the point, considering\n     * the spatialMask if it has been previously set\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    contains(lon, lat) {\n        if (this._spatialMask) {\n            return this._pointInMask(lon, lat);\n        }\n        return this._pointInExtent(lon, lat);\n    }\n\n    /**\n     * Checks if coordinates are inside the Extent (considering wrapped longitudes if needed)\n     * @param {Number} lon \n     * @param {Number} lat \n     */\n    _pointInExtent(lon, lat) {\n        let [xmin, xmax] = this._getWrappedLongitudes();\n        let longitudeIn = lon >= xmin && lon <= xmax;\n        let latitudeIn = lat >= this.yllCorner && lat <= this.yurCorner;\n        return longitudeIn && latitudeIn;\n    }\n\n    /**\n     * Check if coordinates are inside the spatialMask (Point in Polygon analysis)\n     * @param {Number} lon \n     * @param {Number} lat \n     */\n    _pointInMask(lon, lat) {\n        const pt = {\n            type: 'Feature',\n            geometry: {\n                type: 'Point',\n                coordinates: [lon, lat] // geojson, lon-lat order !\n            },\n            properties: {}\n        };\n        const poly = this._spatialMask;\n        return inside(pt, poly);\n    }\n\n    /**\n     * Returns if the grid doesn't contain the point\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    notContains(lon, lat) {\n        return !this.contains(lon, lat);\n    }\n\n    /**\n     * Interpolated value at lon-lat coordinates (bilinear method)\n     * @param   {Number} longitude\n     * @param   {Number} latitude\n     * @returns {Vector|Number} [u, v, magnitude]\n     *                          \n     * Source: https://github.com/cambecc/earth > product.js\n     */\n    interpolatedValueAt(lon, lat) {\n        if (this.notContains(lon, lat)) return null;\n\n        let [i, j] = this._getDecimalIndexes(lon, lat);\n        return this.interpolatedValueAtIndexes(i, j);\n    }\n\n    /**\n     * Interpolated value at i-j indexes (bilinear method)\n     * @param   {Number} i\n     * @param   {Number} j\n     * @returns {Vector|Number} [u, v, magnitude]\n     *\n     * Source: https://github.com/cambecc/earth > product.js\n     */\n    interpolatedValueAtIndexes(i, j) {\n        //         1      2           After converting  and  to fractional grid indexes i and j, we find the\n        //        fi  i   ci          four points 'G' that enclose point (i, j). These points are at the four\n        //         | =1.4 |           corners specified by the floor and ceiling of i and j. For example, given\n        //      ---G--|---G--- fj 8   i = 1.4 and j = 8.3, the four surrounding grid points are (1, 8), (2, 8),\n        //    j ___|_ .   |           (1, 9) and (2, 9).\n        //  =8.3   |      |\n        //      ---G------G--- cj 9   Note that for wrapped grids, the first column is duplicated as the last\n        //         |      |           column, so the index ci can be used without taking a modulo.\n\n        let indexes = this._getFourSurroundingIndexes(i, j);\n        let [fi, ci, fj, cj] = indexes;\n        let values = this._getFourSurroundingValues(fi, ci, fj, cj);\n        if (values) {\n            let [g00, g10, g01, g11] = values;\n            return this._doInterpolation(i - fi, j - fj, g00, g10, g01, g11);\n        }\n        return null;\n    }\n\n    /**\n     * Get decimal indexes\n     * @private\n     * @param {Number} lon\n     * @param {Number} lat\n     * @returns {Array}    [[Description]]\n     */\n    _getDecimalIndexes(lon, lat) {\n        if (this.longitudeNeedsToBeWrapped && lon < this.xllCorner) {\n            lon = lon + 360;\n        }\n        let i = (lon - this.xllCorner) / this.cellXSize;\n        let j = (this.yurCorner - lat) / this.cellYSize;\n        return [i, j];\n    }\n\n    /**\n     * Get surrounding indexes (integer), clampling on borders\n     * @private\n     * @param   {Number} i - decimal index\n     * @param   {Number} j - decimal index\n     * @returns {Array} [fi, ci, fj, cj]\n     */\n    _getFourSurroundingIndexes(i, j) {\n        let fi = Math.floor(i);\n        let ci = fi + 1;\n        // duplicate colum to simplify interpolation logic (wrapped value)\n        if (this.isContinuous && ci >= this.nCols) {\n            ci = 0;\n        }\n        ci = this._clampColumnIndex(ci);\n\n        let fj = this._clampRowIndex(Math.floor(j));\n        let cj = this._clampRowIndex(fj + 1);\n\n        return [fi, ci, fj, cj];\n    }\n\n    /**\n     * Get four surrounding values or null if not available,\n     * from 4 integer indexes\n     * @private\n     * @param   {Number} fi\n     * @param   {Number} ci\n     * @param   {Number} fj\n     * @param   {Number} cj\n     * @returns {Array} \n     */\n    _getFourSurroundingValues(fi, ci, fj, cj) {\n        var row;\n        if ((row = this.grid[fj])) {\n            // upper row ^^\n            var g00 = row[fi]; // << left\n            var g10 = row[ci]; // right >>\n            if (\n                this._isValid(g00) &&\n                this._isValid(g10) &&\n                (row = this.grid[cj])\n            ) {\n                // lower row vv\n                var g01 = row[fi]; // << left\n                var g11 = row[ci]; // right >>\n                if (this._isValid(g01) && this._isValid(g11)) {\n                    return [g00, g10, g01, g11]; // 4 values found!\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Nearest value at lon-lat coordinates\n     * @param   {Number} longitude\n     * @param   {Number} latitude\n     * @returns {Vector|Number}\n     */\n    valueAt(lon, lat) {\n        if (this.notContains(lon, lat)) return null;\n\n        let [i, j] = this._getDecimalIndexes(lon, lat);\n        let ii = Math.floor(i);\n        let jj = Math.floor(j);\n\n        const ci = this._clampColumnIndex(ii);\n        const cj = this._clampRowIndex(jj);\n\n        let value = this._valueAtIndexes(ci, cj);\n        if (this._inFilter) {\n            if (!this._inFilter(value)) return null;\n        }\n\n        return value;\n    }\n\n    /**\n     * Returns whether or not the field has a value at the point\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    hasValueAt(lon, lat) {\n        let value = this.valueAt(lon, lat);\n        let hasValue = value !== null;\n\n        let included = true;\n        if (this._inFilter) {\n            included = this._inFilter(value);\n        }\n        return hasValue && included;\n    }\n\n    /**\n     * Returns if the grid has no value at the point\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    notHasValueAt(lon, lat) {\n        return !this.hasValueAt(lon, lat);\n    }\n\n    /**\n     * Gives a random position to 'o' inside the grid\n     * @param {Object} [o] - an object (eg. a particle)\n     * @returns {{x: Number, y: Number}} - object with x, y (lon, lat)\n     */\n    randomPosition(o = {}) {\n        let i = (Math.random() * this.nCols) | 0;\n        let j = (Math.random() * this.nRows) | 0;\n\n        o.x = this._longitudeAtX(i);\n        o.y = this._latitudeAtY(j);\n\n        return o;\n    }\n\n    /**\n     * Value for grid indexes\n     * @param   {Number} i - column index (integer)\n     * @param   {Number} j - row index (integer)\n     * @returns {Vector|Number}\n     */\n    _valueAtIndexes(i, j) {\n        return this.grid[j][i]; // <-- j,i !!\n    }\n\n    /**\n     * Lon-Lat for grid indexes\n     * @param   {Number} i - column index (integer)\n     * @param   {Number} j - row index (integer)\n     * @returns {Number[]} [lon, lat]\n     */\n    _lonLatAtIndexes(i, j) {\n        let lon = this._longitudeAtX(i);\n        let lat = this._latitudeAtY(j);\n\n        return [lon, lat];\n    }\n\n    /**\n     * Longitude for grid-index\n     * @param   {Number} i - column index (integer)\n     * @returns {Number} longitude at the center of the cell\n     */\n    _longitudeAtX(i) {\n        let halfXPixel = this.cellXSize / 2.0;\n        let lon = this.xllCorner + halfXPixel + i * this.cellXSize;\n        if (this.longitudeNeedsToBeWrapped) {\n            lon = lon > 180 ? lon - 360 : lon;\n        }\n        return lon;\n    }\n\n    /**\n     * Latitude for grid-index\n     * @param   {Number} j - row index (integer)\n     * @returns {Number} latitude at the center of the cell\n     */\n    _latitudeAtY(j) {\n        let halfYPixel = this.cellYSize / 2.0;\n        return this.yurCorner - halfYPixel - j * this.cellYSize;\n    }\n\n    /**\n     * Apply the interpolation\n     * @abstract\n     * @private\n     */\n    /* eslint-disable no-unused-vars */\n    _doInterpolation(x, y, g00, g10, g01, g11) {\n        throw new TypeError('Must be overriden');\n    }\n    /* eslint-disable no-unused-vars */\n\n    /**\n     * Check the column index is inside the field,\n     * adjusting to min or max when needed\n     * @private\n     * @param   {Number} ii - index\n     * @returns {Number} i - inside the allowed indexes\n     */\n    _clampColumnIndex(ii) {\n        let i = ii;\n        if (ii < 0) {\n            i = 0;\n        }\n        let maxCol = this.nCols - 1;\n        if (ii > maxCol) {\n            i = maxCol;\n        }\n        return i;\n    }\n\n    /**\n     * Check the row index is inside the field,\n     * adjusting to min or max when needed\n     * @private\n     * @param   {Number} jj index\n     * @returns {Number} j - inside the allowed indexes\n     */\n    _clampRowIndex(jj) {\n        let j = jj;\n        if (jj < 0) {\n            j = 0;\n        }\n        let maxRow = this.nRows - 1;\n        if (jj > maxRow) {\n            j = maxRow;\n        }\n        return j;\n    }\n\n    /**\n     * Is valid (not 'null' nor 'undefined')\n     * @private\n     * @param   {Object} x object\n     * @returns {Boolean}\n     */\n    _isValid(x) {\n        return x !== null && x !== undefined;\n    }\n}\n","import Field from './Field';\n\n/**\n * Scalar Field\n */\nexport default class ScalarField extends Field {\n    /**\n     * Creates a ScalarField from the content of an ASCIIGrid file\n     * @param   {String}   asc\n     * @returns {ScalarField}\n     */\n    static fromASCIIGrid(asc, scaleFactor = 1) {\n        //console.time('ScalarField from ASC');\n\n        let lines = asc.split('\\n');\n\n        // Header\n        var header = ScalarField._parseASCIIGridHeader(lines.slice(0, 6));\n\n        // Data (left-right and top-down)\n        let zs = [];\n        for (let i = 6; i < lines.length; i++) {\n            let line = lines[i].trim();\n            if (line === '') break;\n\n            let items = line.split(' ');\n            items.forEach(it => {\n                let floatItem = parseFloat(it);\n                let v =\n                    floatItem !== header.noDataValue\n                        ? floatItem * scaleFactor\n                        : null;\n                zs.push(v);\n            });\n        }\n        let p = header;\n        p.zs = zs;\n\n        //console.timeEnd('ScalarField from ASC');\n        return new ScalarField(p);\n    }\n\n    /**\n     * Parse an ASCII Grid header, made with 6 lines\n     * It allows the use of XLLCORNER/YLLCORNER or XLLCENTER/YLLCENTER conventions\n     * @param {Array.String} headerLines\n     */\n    static _parseASCIIGridHeader(headerLines) {\n        try {\n            const headerItems = headerLines.map(line => {\n                var items = line.split(' ').filter(i => i != '');\n                var param = items[0].trim().toUpperCase();\n                var value = parseFloat(items[1].trim());\n                return { [param]: value };\n            });\n\n            const usesCorner = 'XLLCORNER' in headerItems[2];\n            const cellSize = headerItems[4]['CELLSIZE'];\n\n            const header = {\n                nCols: parseInt(headerItems[0]['NCOLS']),\n                nRows: parseInt(headerItems[1]['NROWS']),\n                xllCorner: usesCorner\n                    ? headerItems[2]['XLLCORNER']\n                    : headerItems[2]['XLLCENTER'] - cellSize,\n                yllCorner: usesCorner\n                    ? headerItems[3]['YLLCORNER']\n                    : headerItems[3]['YLLCENTER'] - cellSize,\n                cellXSize: cellSize,\n                cellYSize: cellSize,\n                noDataValue: headerItems[5]['NODATA_VALUE']\n            };\n            return header;\n        } catch (err) {\n            throw new Error(`Not a valid ASCIIGrid Header: ${err}`);\n        }\n    }\n\n    /**\n     * Creates a ScalarField from the content of a GeoTIFF file\n     * @param   {ArrayBuffer}   data\n     * @param   {Number}   bandIndex\n     * @returns {ScalarField}\n     */\n    static fromGeoTIFF(data, bandIndex = 0) {\n        return ScalarField.multipleFromGeoTIFF(data, [bandIndex])[0];\n    }\n\n    /**\n     * Creates a ScalarField array (one per band) from the content of a GeoTIFF file\n     * @param   {ArrayBuffer}   data\n     * @param   {Array}   bandIndexes - if not provided all bands are returned\n     * @returns {Array.<ScalarField>}\n     */\n    static multipleFromGeoTIFF(data, bandIndexes) {\n        //console.time('ScalarField from GeoTIFF');\n\n        let tiff = GeoTIFF.parse(data); // geotiff.js\n        let image = tiff.getImage();\n        let rasters = image.readRasters();\n        let tiepoint = image.getTiePoints()[0];\n        let fileDirectory = image.getFileDirectory();\n        let [xScale, yScale] = fileDirectory.ModelPixelScale;\n\n        if (typeof bandIndexes === 'undefined' || bandIndexes.length === 0) {\n            bandIndexes = [...Array(rasters.length).keys()];\n        }\n\n        let scalarFields = [];\n        scalarFields = bandIndexes.map(function(bandIndex) {\n            let zs = rasters[bandIndex]; // left-right and top-down order\n\n            if (fileDirectory.GDAL_NODATA) {\n                let noData = parseFloat(fileDirectory.GDAL_NODATA);\n                // console.log(noData);\n                let simpleZS = Array.from(zs); // to simple array, so null is allowed | TODO efficiency??\n                zs = simpleZS.map(function(z) {\n                    return z === noData ? null : z;\n                });\n            }\n\n            let p = {\n                nCols: image.getWidth(),\n                nRows: image.getHeight(),\n                xllCorner: tiepoint.x,\n                yllCorner: tiepoint.y - image.getHeight() * yScale,\n                cellXSize: xScale,\n                cellYSize: yScale,\n                zs: zs\n            };\n            return new ScalarField(p);\n        });\n\n        //console.timeEnd('ScalarField from GeoTIFF');\n        return scalarFields;\n    }\n\n    constructor(params) {\n        super(params);\n        this.zs = params['zs'];\n\n        this.grid = this._buildGrid();\n        this._updateRange();\n        //console.log(`ScalarField created (${this.nCols} x ${this.nRows})`);\n    }\n\n    /**\n     * Builds a grid with a Number at each point, from an array\n     * 'zs' following x-ascending & y-descending order\n     * (same as in ASCIIGrid)\n     * @private\n     * @returns {Array.<Array.<Number>>} - grid[row][column]--> Number\n     */\n    _buildGrid() {\n        let grid = this._arrayTo2d(this.zs, this.nRows, this.nCols);\n        return grid;\n    }\n\n    _arrayTo2d(array, nRows, nCols) {\n        let grid = [];\n        let p = 0;\n        for (var j = 0; j < nRows; j++) {\n            var row = [];\n            for (var i = 0; i < nCols; i++, p++) {\n                let z = array[p];\n                row[i] = this._isValid(z) ? z : null; // <<<\n            }\n            grid[j] = row;\n        }\n        return grid;\n    }\n\n    _newDataArrays(params) {\n        params['zs'] = [];\n    }\n\n    _pushValueToArrays(params, value) {\n        params['zs'].push(value);\n    }\n\n    _makeNewFrom(params) {\n        return new ScalarField(params);\n    }\n\n    /**\n     * Calculate min & max values\n     * @private\n     * @returns {Array} - [min, max]\n     */\n    _calculateRange() {\n        var data = this.zs;\n        if (this._inFilter) {\n            data = data.filter(this._inFilter);\n        }\n        return [d3.min(data), d3.max(data)];\n    }\n\n    /**\n     * Bilinear interpolation for Number\n     * https://en.wikipedia.org/wiki/Bilinear_interpolation\n     * @param   {Number} x\n     * @param   {Number} y\n     * @param   {Number} g00\n     * @param   {Number} g10\n     * @param   {Number} g01\n     * @param   {Number} g11\n     * @returns {Number}\n     */\n    _doInterpolation(x, y, g00, g10, g01, g11) {\n        var rx = 1 - x;\n        var ry = 1 - y;\n        return g00 * rx * ry + g10 * x * ry + g01 * rx * y + g11 * x * y;\n    }\n}\n","import Vector from './Vector';\nimport Field from './Field';\nimport ScalarField from './ScalarField';\n\n/**\n *  A set of vectors assigned to a regular 2D-grid (lon-lat)\n *  (e.g. a raster representing winds for a region)\n */\nexport default class VectorField extends Field {\n    /**\n     * Creates a VectorField from the content of two ASCIIGrid files\n     * @param   {String} ascU - with u-component\n     * @param   {String} ascV - with v-component\n     * @returns {VectorField}\n     */\n    static fromASCIIGrids(ascU, ascV, scaleFactor = 1) {\n        let u = ScalarField.fromASCIIGrid(ascU, scaleFactor);\n        let v = ScalarField.fromASCIIGrid(ascV, scaleFactor);\n        let p = VectorField._paramsFromScalarFields(u, v);\n\n        return new VectorField(p);\n    }\n\n    /**\n     * Creates a VectorField from the content of two different Geotiff files\n     * @param   {ArrayBuffer} gtU - geotiff data with u-component (band 0)\n     * @param   {ArrayBuffer} gtV - geotiff data with v-component (band 0)\n     * @returns {VectorField}\n     */\n    static fromGeoTIFFs(gtU, gtV) {\n        let u = ScalarField.fromGeoTIFF(gtU);\n        let v = ScalarField.fromGeoTIFF(gtV);\n        let p = VectorField._paramsFromScalarFields(u, v);\n\n        return new VectorField(p);\n    }\n\n    /**\n     * Creates a VectorField from the content of Multiband Geotiff\n     * @param   {ArrayBuffer} geotiffData - multiband\n     * @param   {Array} bandIndexesForUV\n     * @returns {VectorField}\n     */\n    static fromMultibandGeoTIFF(geotiffData, bandIndexesForUV = [0, 1]) {\n        let [u, v] = ScalarField.multipleFromGeoTIFF(\n            geotiffData,\n            bandIndexesForUV\n        );\n        let p = VectorField._paramsFromScalarFields(u, v);\n\n        return new VectorField(p);\n    }\n\n    /**\n     * Build parameters for VectorField, from 2 ScalarFields.\n     * No validation at all (nor interpolation) is applied, so u and v\n     * must be 'compatible' from the source\n     * @param   {ScalarField} u\n     * @param   {ScalarField} v\n     * @returns {Object} - parameters to build VectorField\n     */\n    static _paramsFromScalarFields(u, v) {\n        // TODO check u & v compatibility (cellSize...)\n        let p = {\n            nCols: u.nCols,\n            nRows: u.nRows,\n            xllCorner: u.xllCorner,\n            yllCorner: u.yllCorner,\n            cellXSize: u.cellXSize,\n            cellYSize: u.cellYSize,\n            us: u.zs,\n            vs: v.zs\n        };\n        return p;\n    }\n\n    constructor(params) {\n        super(params);\n\n        this.us = params['us'];\n        this.vs = params['vs'];\n        this.grid = this._buildGrid();\n        this.range = this._calculateRange();\n    }\n\n    /**\n     * Get a derived field, from a computation on\n     * the VectorField\n     * @param   {String} type ['magnitude' | 'directionTo' | 'directionFrom']\n     * @returns {ScalarField}\n     */\n    getScalarField(type) {\n        let f = this._getFunctionFor(type);\n        let p = {\n            nCols: this.params.nCols,\n            nRows: this.params.nRows,\n            xllCorner: this.params.xllCorner,\n            yllCorner: this.params.yllCorner,\n            cellXSize: this.params.cellXSize,\n            cellYSize: this.params.cellYSize,\n            zs: this._applyOnField(f)\n        };\n        return new ScalarField(p);\n    }\n\n    _getFunctionFor(type) {\n        return function(u, v) {\n            let uv = new Vector(u, v);\n            return uv[type](); // magnitude, directionTo, directionFrom\n        };\n    }\n\n    _applyOnField(func) {\n        let zs = [];\n        let n = this.numCells();\n        for (var i = 0; i < n; i++) {\n            let u = this.us[i];\n            let v = this.vs[i];\n            if (this._isValid(u) && this._isValid(v)) {\n                zs.push(func(u, v));\n            } else {\n                zs.push(null);\n            }\n        }\n        return zs;\n    }\n\n    /**\n     * Builds a grid with a Vector at each point, from two arrays\n     * 'us' and 'vs' following x-ascending & y-descending order\n     * (same as in ASCIIGrid)\n     * @returns {Array.<Array.<Vector>>} - grid[row][column]--> Vector\n     */\n    _buildGrid() {\n        let grid = this._arraysTo2d(this.us, this.vs, this.nRows, this.nCols);\n        return grid;\n    }\n\n    _arraysTo2d(us, vs, nRows, nCols) {\n        let grid = [];\n        let p = 0;\n\n        for (var j = 0; j < nRows; j++) {\n            var row = [];\n            for (var i = 0; i < nCols; i++, p++) {\n                let u = us[p],\n                    v = vs[p];\n                let valid = this._isValid(u) && this._isValid(v);\n                row[i] = valid ? new Vector(u, v) : null; // <<<\n            }\n            grid[j] = row;\n        }\n        return grid;\n    }\n\n    _newDataArrays(params) {\n        params['us'] = [];\n        params['vs'] = [];\n    }\n    _pushValueToArrays(params, value) {\n        //console.log(value);\n        params['us'].push(value.u);\n        params['vs'].push(value.v);\n    }\n    _makeNewFrom(params) {\n        return new VectorField(params);\n    }\n\n    /**\n     * Calculate min & max values (magnitude)\n     * @private\n     * @returns {Array}\n     */\n    _calculateRange() {\n        // TODO make a clearer method for getting these vectors...\n        let vectors = this.getCells()\n            .map(pt => pt.value)\n            .filter(function(v) {\n                return v !== null;\n            });\n\n        if (this._inFilter) {\n            vectors = vectors.filter(this._inFilter);\n        }\n\n        // TODO check memory crash with high num of vectors!\n        let magnitudes = vectors.map(v => v.magnitude());\n        let min = d3.min(magnitudes);\n        let max = d3.max(magnitudes);\n\n        return [min, max];\n    }\n\n    /**\n     * Bilinear interpolation for Vector\n     * https://en.wikipedia.org/wiki/Bilinear_interpolation\n     * @param   {Number} x\n     * @param   {Number} y\n     * @param   {Number[]} g00\n     * @param   {Number[]} g10\n     * @param   {Number[]} g01\n     * @param   {Number[]} g11\n     * @returns {Vector}\n     */\n    _doInterpolation(x, y, g00, g10, g01, g11) {\n        var rx = 1 - x;\n        var ry = 1 - y;\n        var a = rx * ry,\n            b = x * ry,\n            c = rx * y,\n            d = x * y;\n        var u = g00.u * a + g10.u * b + g01.u * c + g11.u * d;\n        var v = g00.v * a + g10.v * b + g01.v * c + g11.v * d;\n        return new Vector(u, v);\n    }\n\n    /**\n     * Is valid (not 'null' nor 'undefined')\n     * @private\n     * @param   {Object} x object\n     * @returns {Boolean}\n     */\n    _isValid(x) {\n        return x !== null && x !== undefined;\n    }\n}\n","// base\nimport Vector from './Vector.js';\nwindow.L.Vector = Vector;\n\nimport Cell from './Cell.js';\nwindow.L.Cell = Cell;\n\nimport Field from './Field.js';\nwindow.L.Field = Field;\n\nimport ScalarField from './ScalarField.js';\nwindow.L.ScalarField = ScalarField;\n\nimport VectorField from './VectorField.js';\nwindow.L.VectorField = VectorField;\n\n// layer\nrequire('./layer/L.CanvasLayer.js');\nrequire('./layer/L.CanvasLayer.SimpleLonLat.js');\nrequire('./layer/L.CanvasLayer.Field.js');\nrequire('./layer/L.CanvasLayer.ScalarField.js');\nrequire('./layer/L.CanvasLayer.VectorFieldAnim.js');\n\n// control\nrequire('./control/L.Control.ColorBar.js');\n\n/* eslint-disable no-console */\nconsole.log('leaflet.canvaslayer.field v1.4.1');\n/* eslint-enable no-console */\n"],"sourceRoot":""}